name: Deploy EKS Cluster and Argo CD

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  id-token: write # Required for OIDC
  contents: read

env:
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
  CLUSTER_NAME: ${{ vars.CLUSTER_NAME || 'logicall-ai-cluster' }}
  AWS_ROLE_ARN: ${{ vars.AWS_ROLE_ARN }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: AWS
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          role-session-name: GitHubActions-Deploy
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Terraform Init - EKS
        working-directory: infra/eks
        run: terraform init

      - name: Import existing resources (if any)
        working-directory: infra/eks
        continue-on-error: true
        run: |
          # Import CloudWatch log group
          terraform import aws_cloudwatch_log_group.cluster /aws/eks/${{ env.CLUSTER_NAME }}/cluster 2>/dev/null || echo "Log group already in state or doesn't exist"
          
          # Import IAM roles
          terraform import aws_iam_role.cluster ${{ env.CLUSTER_NAME }}-cluster-role 2>/dev/null || echo "Cluster role already in state or doesn't exist"
          terraform import aws_iam_role.node_group ${{ env.CLUSTER_NAME }}-node-group-role 2>/dev/null || echo "Node group role already in state or doesn't exist"
          
          # Import EKS cluster (this will also import dependent resources)
          terraform import aws_eks_cluster.main ${{ env.CLUSTER_NAME }} 2>/dev/null || echo "Cluster already in state or doesn't exist"
          
          # Refresh state to sync with actual resources
          terraform refresh -auto-approve || true

      - name: Terraform Apply - EKS
        working-directory: infra/eks
        timeout-minutes: 45
        run: terraform apply -auto-approve

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}
          kubectl cluster-info

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.13.0'

      - name: Install AWS Load Balancer Controller
        run: |
          # Note: IAM role for AWS Load Balancer Controller should be created via Terraform
          # This step installs the controller using Helm
          helm repo add eks https://aws.github.io/eks-charts
          helm repo update
          
          # Create service account (IAM role will be attached via Terraform)
          kubectl create serviceaccount aws-load-balancer-controller -n kube-system --dry-run=client -o yaml | kubectl apply -f -
          
          helm upgrade --install aws-load-balancer-controller eks/aws-load-balancer-controller \
            -n kube-system \
            --set clusterName=${{ env.CLUSTER_NAME }} \
            --set serviceAccount.create=false \
            --set serviceAccount.name=aws-load-balancer-controller \
            --set region=${{ env.AWS_REGION }} \
            --wait

      - name: Install External Secrets Operator
        run: |
          helm repo add external-secrets https://charts.external-secrets.io
          helm repo update
          
          helm upgrade --install external-secrets external-secrets/external-secrets \
            -n external-secrets \
            --create-namespace \
            --set installCRDs=true \
            --wait

      - name: Install Argo CD
        run: |
          kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -
          kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          
          echo "Waiting for Argo CD to be ready..."
          kubectl wait --for=condition=available deployment/argocd-server -n argocd --timeout=300s
          
          echo "Exposing Argo CD UI via LoadBalancer..."
          kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'

      - name: Apply Argo CD root application
        run: |
          echo "Applying root-app Argo CD application..."
          kubectl apply -f gitops/argocd/root-app.yaml
          
          echo "Waiting for root-app to sync..."
          # Give Argo CD a moment to pick up the new file
          sleep 20
          kubectl wait --for=condition=healthy application/root-app -n argocd --timeout=300s || echo "Wait timed out, but proceeding to status check..."

      - name: Final Status and Credentials
        run: |
          echo "--- Deployment Summary ---"
          echo "Argo CD URL:"
          kubectl get svc argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'
          echo ""
          echo "Argo CD Admin Password:"
          kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d
          echo ""
          echo "Nginx App URL:"
          kubectl get svc nginx-hello -n apps -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || echo "Pending..."